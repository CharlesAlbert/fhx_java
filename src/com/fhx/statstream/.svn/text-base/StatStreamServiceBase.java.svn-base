package com.fhx.statstream;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;
import org.marketcetera.marketdata.interactivebrokers.LatestMarketData;
import org.rosuda.REngine.REXP;
import org.rosuda.REngine.REXPDouble;
import org.rosuda.REngine.REXPInteger;
import org.rosuda.REngine.REXPString;
import org.rosuda.REngine.RList;
import org.rosuda.REngine.Rserve.RConnection;

import com.fhx.util.StatStreamUtil;


public abstract class StatStreamServiceBase {

	private static Logger log = Logger.getLogger(StatStreamServiceBase.class);
	private final Properties config = new Properties();
	
	protected static RConnection conn;  // have a global R connection handler for simplicity
	
	public void init() {
		PropertyConfigurator.configure("conf/log4j.properties");
		
		setupRServe();
		setupREnvironment();
	}
	
	public void setupRServe() {
		
		try {
			config.load(this.getClass().getClassLoader().getResourceAsStream("conf/statstream.properties"));
		} catch (IOException e1) {
			log.error("Error loading config file\n");
			e1.printStackTrace();
			return;
		}
		
		// start up Rserve service if not running 
		System.out.println("result="+StatStreamUtil.checkLocalRserve());
		try {
			String host = config.getProperty("HOST");
			conn = new RConnection(host);
		} catch (Exception e) {
			log.error("Error creating new RConnection on localhost\n" );
			e.printStackTrace();
		};
	}
	
	public void setupREnvironment() {
		final String mainRFile = config.getProperty("R_MAIN_SCRIPT");
		final String funcRFile = config.getProperty("R_FUNC_SCRIPT");
		
		log.info("Make sure rScript ("+mainRFile+") exists in your runtime env.");
		log.info("Make sure rScript ("+funcRFile+") exists in your runtime env.");
		
		File mainFile = new File(mainRFile);
		File funcFile = new File(funcRFile);
		
		if (!mainFile.exists() || !funcFile.exists()) {
			log.error("mainRFIle or funcRFIle doesn't exist, exiting...");
			System.exit(1);			
		}
		
		try {
			// source the main R file to initialize global variables referenced by R functions
			REXP mList = conn.parseAndEval("source('"+mainRFile+"')");
			REXP fList = conn.parseAndEval("source('"+funcRFile+"')");
			System.out.println("mainR(debug): "+mList);
			System.out.println("funcR(debug): "+fList);
			
			// check that all global variables exists 
			REXP cmd_ls = conn.parseAndEval("ls()");
			System.out.println("cmd_ls(debug): "+cmd_ls.toDebugString());
			
			String initStatus = conn.parseAndEval("init_status").asString();
			log.info("RList from mainR: " + initStatus);
			
			if (!"SUCCESS".equals(initStatus)) {
				log.error("R model intialization failure, exiting...");
				// it's important we don't start the model if initialization failed
				System.exit(1);
			}
			
		} catch (Exception e) {
			log.error("Failed in Rserver call");
			e.printStackTrace();
			// think about recover here, i.e. Re-intialize R session and try again.
			// recover is important as all important data are stored in R.
		}
	}
	
	protected RList getBasicWindowRList(Map<String, List<LatestMarketData>> aTick) {
		
		RList bwList = new RList();
	
		try {	
			log.info("Creating basic window and pass it to R: ");
			
			List<String> streamID = new ArrayList<String>();
			List<Integer> timePoint = new ArrayList<Integer>();
			List<Double> value = new ArrayList<Double>();
			BigDecimal bid;
			BigDecimal ask;
			BigDecimal mid;
			
			for(Map.Entry<String, List<LatestMarketData>> entry : aTick.entrySet()) {
				String symbol = entry.getKey();
				List<LatestMarketData> basicWindowData = entry.getValue();
				
				for(int timePt = 0; timePt < basicWindowData.size(); timePt++) {
					streamID.add(symbol);
					timePoint.add(timePt);
					bid = basicWindowData.get(timePt).getLatestBid().getPrice();
					ask = basicWindowData.get(timePt).getLatestOffer().getPrice();
					mid = bid.add(ask).divide(new BigDecimal(2));
					mid.setScale(4);   // two decimal points
					value.add(mid.doubleValue());	
				}
			}
			
			log.info("XXXX streamID size = "+streamID.size()+"\n");
			log.info("XXXX data points size = "+value.size()+"\n");
			
			for(int i = 0; i < value.size(); i++) {
				log.info(streamID.get(i)+"(" + timePoint.get(i)+"): "+value.get(i)+"\n");
			}
			
			bwList.put("streamID", new REXPString(streamID.toArray(new String[streamID.size()])));
			bwList.put("timepoint", new REXPInteger(ArrayUtils.toPrimitive(timePoint.toArray(new Integer[timePoint.size()]))));
			bwList.put("value", new REXPDouble(ArrayUtils.toPrimitive(value.toArray(new Double[value.size()]))));
			
			log.info("XXXX bwList: " +bwList);
			
		} catch (Exception e) {
	            System.err.println(e);
	            System.exit(1);
	    }
		
		return bwList;
	}
	
	public abstract boolean tick(Map<String, List<LatestMarketData>> aTick);
		
}
